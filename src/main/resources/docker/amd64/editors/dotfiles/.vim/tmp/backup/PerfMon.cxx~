/*
 (c) Copyright, Real-Time Innovations, $Date: 2007/01/16 22:36:34 $.
 All rights reserved.
 No duplications, whole or partial, manual or electronic, may be made
 without express written permission.  Any such copies, or
 revisions thereof, must display this notice unaltered.
 This code contains trade secrets of Real-Time Innovations, Inc.
*/

/*
To create and use an effective performance monitoring application:

   1. Decide which counters (i.e. processes, etc.) you wish to monitor.
   2. Decide which instances you wish to apply these counters to, if applicable.
   3. Decide upon application design issues, such as the duration of the
      monitoring and monitoring intervals.
   4. Write the code to do the monitoring, incorporating the following basic
      steps:
          * create a query
          * associate counters with the query
          * collect and process the data
          * close the query. 
   5. Run the application.
   6. Analyze the data. 
*/
#include <stdio.h>
#include "log/log_makeheader.h"
#include "log/log_common.h"
#include "osapi/osapi_process.h"
#include "osapi/osapi_utility.h"

#include "ThroughputArgs.h"
#include "PerfMon.h"
#include "ThroughputCommon.h"

#ifdef RTI_LINUX
  #include <stdio.h>
  #include <string.h>
  #include <errno.h>
  #include <sys/time.h>
  #include <unistd.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  #include <asm/param.h> /* <elf.h> */

PerfMon::~PerfMon() {}

PerfMon::PerfMon(const char* nic, RTI_UINT32 pid)
    : Hertz(0),
      ms_nic(nic) {
    const char* METHOD_NAME = "PerfMon::PerfMon";

    if (pid == 0) _pid = RTIOsapiProcess_getId();

    long smp_num_cpus = sysconf(_SC_NPROCESSORS_ONLN);
    /* SPARC glibc is buggy */
    Cpu_tot = RTIOsapiUtility_max(smp_num_cpus, 1);
  #ifndef HZ
    #error "This code will not work"
  #endif
    Hertz = HZ;

    if (Hertz == 0) {
        AppLog_exception("sysconf(_SC_NPROCESSORS_ONLN) failed");
    }
    getCpu(); /*the first run; result will be garbage so just ignore */
}

int PerfMon::isValid() {
    return(Hertz && readProcNetDev(&mStatNetDev_initial));
};


RTIBool PerfMon::readProcNetDev(struct NetDevStat* stat) {
    RTIBool ok = 0;
    int file = -1, bytesRead;
    int numScanned;
    unsigned long garbage_ulong;
    char *S, buf[1024];
    const char* METHOD_NAME = "PerfMon::readProcNetDev";

    if (ms_nic == NULL) {
        goto fin;
    }

    file = open("/proc/net/dev", O_RDONLY, 0);
    if (file == -1) {
        AppLog_exception("open /proc/net/dev failed %d", errno);
        goto fin;
    }
    
    bytesRead = read(file, buf, sizeof(buf) - 1);
    if (bytesRead <= 0) {
        AppLog_exception("read failed %d", errno);
        goto fin;
    }
    buf[bytesRead] = 0; /* terminating NULL */

    /* AppLog_exception(METHOD_NAME, &RTI_LOG_ANY_s, ms_nic); */
    S = strstr(buf, ms_nic);
    if (S == NULL) {
        AppLog_exception("%s failed to find %s\n", METHOD_NAME, ms_nic);
        goto fin;
    }
    S = strchr(S, ':');
    if (S == NULL) goto fin;
    ++S; /* skip the : */

    numScanned =
        sscanf(S,
               /*bytes packets errs drop fifo frame compressed multicast */
               "%lu %lu %lu %lu %lu %lu %lu %lu "
               /*bytes packets errs drop fifo colls carrier compressed */
               "%lu %lu %lu %lu %lu %lu %lu %lu",
               &stat->byte_recv, &stat->packet_recv,
               &stat->err_recv, &stat->drop_recv,
               &garbage_ulong, &garbage_ulong, &garbage_ulong,
               &stat->mcast_recv,
               
               &stat->byte_sent,&stat->packet_sent,
               &stat->err_sent, &stat->drop_sent,
               &garbage_ulong,&stat->colls_sent,&garbage_ulong, &garbage_ulong);
    if (numScanned != 16) {
        AppLog_exception("%s sscanf failed %d", METHOD_NAME, numScanned);
        goto fin;
    }

    ok = RTI_TRUE;
 fin:
    return ok;
}

RTIBool PerfMon::readProcStat()
{
    RTIBool ok = 0;
    int file = -1, bytesRead;
    char state;
    unsigned long garbage_ulong;
    int garbage_int;
    long garbage_long;
    unsigned long long cutime, cstime, garbage_longlong;
    int numScanned;
    char *S, *tmp, buf[1024], fname[40];
    const char* METHOD_NAME = "PerfMon::readProcStat";

    sprintf(fname, "/proc/%d/stat", _pid);
    file = open(fname, O_RDONLY, 0);
    if (file == -1) {
        AppLog_exception("failed to open %s", fname);
        goto fin;
    }
    
    bytesRead = read(file, buf, sizeof(buf) - 1);
    if (bytesRead <= 0) {
        AppLog_exception("%s read failed %d", METHOD_NAME, errno);
        goto fin;
    }

    buf[bytesRead] = 0; /* terminating NULL */

    /* look for the command name inside parenthesis */
    S = strchr(buf, '(') + 1;
    tmp = strrchr(S, ')');
    if (!S || !tmp) {
        AppLog_exception("%s strchr failed %d", METHOD_NAME, errno);
        goto fin;
    }

#ifdef UNNECESSARY
    num = tmp - S;
    if (unlikely(num >= sizeof P->cmd)) {
        num = sizeof P->cmd - 1;
    }
    memcpy(P->cmd, S, num);
    P->cmd[num] = '\0';
#endif
    S = tmp + 2; /* skip ") " */

    /* and the rest are just bunch of numbers, so just read them in */
    numScanned = sscanf(S,
               "%c "                                               /* 1 */
               "%d %d %d %d %d "                                   /* + 5 */
               "%lu %lu %lu %lu %lu "                              /* + 5 */
               "%Lu %Lu %Lu %Lu "  /* utime stime cutime cstime */ /* + 4 */
               "%ld %ld "                                          /* + 2 */
               "%d "                                               /* + 1 */
               "%ld "                                              /* + 1 */
               "%Lu " /* start_time */                             /* + 1 */
               "%lu " /* vsize */                                  /* + 1 */
               ,                                                   /* = 21 */
               &state,
               &garbage_int, &garbage_int, &garbage_int, &garbage_int,
               &garbage_int,
               &garbage_ulong, &garbage_ulong, &garbage_ulong, &garbage_ulong,
               &garbage_ulong,
               &mStat_process.utime, &mStat_process.stime, &cutime, &cstime,
               &garbage_long, &garbage_long,
               &garbage_int,
               &garbage_long,
               &garbage_longlong,/* start_time */
               &mStat_process.vsize); /* vsize [bytes] */
    if (numScanned != 21) {
        AppLog_exception("%s sscanf failed %d", METHOD_NAME, numScanned);
        goto fin;
    }

    ok = RTI_TRUE;
 fin:
    if (file != -1) {
        close(file);
    }
    return ok;
}

float PerfMon::getCpu() {
    float cpuUsed = -1.0f, et, Frame_tscale;
    struct timeval timev;
    unsigned long long tics = prevtic;
    unsigned long pcpu = 0;
    const char* METHOD_NAME = "PerfMon::getCpu";

    if (!readProcStat()) {
        AppLog_exception("failed to read /proc/[pid]/stat");
        goto fin;
    }

    tics = mStat_process.utime + mStat_process.stime;
    pcpu = tics - prevtic;

    /* TODO: use RDTSC to get a finer time resolution */
    prevtic = tics; /* save into history, so we can get the delta next time */

    gettimeofday(&timev, NULL); /* don't care about the timezone */
    et = /* means elapsed time, in [sec] */
        (timev.tv_sec - oldtimev.tv_sec)
        + (float)(timev.tv_usec - oldtimev.tv_usec) / 1000000.0;

    Frame_tscale = (et > 0.0f) ? 100.0f / ((float)Hertz * et /* * Cpu_tot */) : 1.0f;

    oldtimev = timev;

    cpuUsed = (float)pcpu * Frame_tscale;
    if (cpuUsed > 100.0f) cpuUsed = 100.0f;
 fin:
    return cpuUsed;
}

unsigned long PerfMon::getMemory() {
    const char* METHOD_NAME = "PerfMon::getMemory";

    if (!readProcStat()) {
        AppLog_exception("failed to read /proc/[pid]/stat");
        return 0;
    }
    return mStat_process.vsize;
}

RTIBool PerfMon::getNetDevStat() {
    return readProcNetDev(&mStatNetDev_current);
}
unsigned long PerfMon::getByteReceived() {
    return(mStatNetDev_current.byte_recv - mStatNetDev_initial.byte_recv);
}
unsigned long PerfMon::getPacketReceived() {
    return(mStatNetDev_current.packet_recv - mStatNetDev_initial.packet_recv);
}
unsigned long PerfMon::getErrorReceived() {
    return(mStatNetDev_current.err_recv - mStatNetDev_initial.err_recv);
}
unsigned long PerfMon::getDropReceived() {
    return(mStatNetDev_current.drop_recv - mStatNetDev_initial.drop_recv);
}
unsigned long PerfMon::getMcastReceived() {
    return(mStatNetDev_current.mcast_recv - mStatNetDev_initial.mcast_recv);
}
unsigned long PerfMon::getByteSent() {
    return(mStatNetDev_current.byte_sent - mStatNetDev_initial.byte_sent);
}
unsigned long PerfMon::getPacketSent() {
    return(mStatNetDev_current.packet_sent - mStatNetDev_initial.packet_sent);
}
unsigned long PerfMon::getErrorSent() {
    return(mStatNetDev_current.err_sent - mStatNetDev_initial.err_sent);
}
unsigned long PerfMon::getDropSent() {
    return(mStatNetDev_current.drop_sent - mStatNetDev_initial.drop_sent);
}
unsigned long PerfMon::getCollisions() {
    return(mStatNetDev_current.colls_sent - mStatNetDev_initial.colls_sent);
}


#elif defined(RTI_WIN32)

#include <windows.h>
#include <pdh.h>
#include <PDHMSG.H>
#include <WINPERF.H>

PerfMon::~PerfMon() {
    PDH_STATUS pdhStatus;
    pdhStatus = PdhRemoveCounter(phCounter);
    if (pdhStatus != ERROR_SUCCESS) {
        AppLog_exception("PhdRemoveCounter failed %d\n", pdhStatus);
    }
    pdhStatus = PdhCloseQuery(hQuery);
    if (pdhStatus != ERROR_SUCCESS) {
        AppLog_exception("PhdCloseQuery failed %d\n", pdhStatus);
    }
}

PerfMon::PerfMon(const char* exe_name) {
    PDH_STATUS pdhStatus;
    char objectName[160];
    CHAR szFullCounterPath[1024];
    DWORD dwpcchBufferSize = 1024; /* PDH_MAX_COUNTER_PATH; */

    sprintf(objectName, "Process(%s)", exe_name);

    pdhStatus = PdhOpenQuery(
        NULL, /* String which refers to the log file from which to
                 read. For real time data capture, specify a value
                 of NULL. */
        0, /* User-defined value to be associated with this query.
              This could be a unique value to identify the query,
              or, if no value is assigned, then a C++ WORD/DWORD
              datatype of 0 would be sufficient. */
        &hQuery /* OUT.  Points to the handle of the created query.
                   This pointer is required in any subsequent PDH
                   function call. */);
    if (pdhStatus != ERROR_SUCCESS) {
        AppLog_exception("PdhOpenQuery failed %d\n", pdhStatus); return;
    }

    PDH_COUNTER_PATH_ELEMENTS spdhCPE;
    spdhCPE.szMachineName = NULL; /* optional "Emerald"; */
    spdhCPE.szObjectName = objectName; /* required */
    /* If the instance name argument is NULL, then no instance reference will
       be inserted into the path string and the szParentInstance and the
       dwInstanceIndex members will be ignored. */
    spdhCPE.szInstanceName = NULL; /* optional */
    spdhCPE.szParentInstance = NULL; /* optional */
    spdhCPE.szCounterName = "% Processor Time";

    pdhStatus = PdhMakeCounterPath(&spdhCPE, szFullCounterPath,
                                   &dwpcchBufferSize, 0 /* dwFlags */ );
    if (pdhStatus != ERROR_SUCCESS) {
        AppLog_exception("PdhMakeCounterPath failed %d\n", pdhStatus); return;
    }

    pdhStatus = PdhAddCounter(
                    hQuery,/* Handle to the query you wish this counter to be
                              added to. Returned from PdhOpenQuery */
                    szFullCounterPath,/* initialized w/ PdhMakeCounterPath */
                    0,/* User-defined value to be associated with this query.
                         This could be a unique value to identify the query,
                         or, if no value is assigned, then a C++ WORD/DWORD
                         datatype of 0 would be sufficient. */
                    &phCounter/* OUT. Points to the handle of the created
                                 counter. */);
    if (pdhStatus != ERROR_SUCCESS) {
        AppLog_exception("PdhAddCounter failed %d\n", pdhStatus); return;
    }
    getCpu();
}

int PerfMon::isValid() {
    return(hQuery
           && getCpu() >= 0.0f);
}

float PerfMon::getCpu() {
    float ok = -1.0f;
    DWORD dwCounterType;
    PDH_FMT_COUNTERVALUE load;
    PDH_STATUS pdhStatus;

    pdhStatus = PdhCollectQueryData(hQuery);
    if (pdhStatus != ERROR_SUCCESS) {
        AppLog_exception("PdhCollectQueryData failed %d\n", pdhStatus);
        goto fin;
    }
    pdhStatus = PdhGetFormattedCounterValue(phCounter,
                                            PDH_FMT_DOUBLE, &dwCounterType,
                                            &load);
    switch(pdhStatus) {
        case ERROR_SUCCESS:
        case PDH_INVALID_DATA: /* this seems to happen on Win2k */
            ok = (float)load.doubleValue;
            break;
        default:
            AppLog_exception("PdhGetFormattedCounterValue failed %d\n",
                             pdhStatus);
            goto fin;
    }

fin:
    return ok;
}

unsigned long PerfMon::getMemory() { return 0; }
RTIBool PerfMon::getNetDevStat() { return RTI_TRUE; }
unsigned long PerfMon::getByteReceived() { return 0; }
unsigned long PerfMon::getPacketReceived() { return 0; }
unsigned long PerfMon::getErrorReceived() { return 0; }
unsigned long PerfMon::getDropReceived() { return 0; }
unsigned long PerfMon::getMcastReceived() { return 0; }
unsigned long PerfMon::getByteSent() { return 0; }
unsigned long PerfMon::getPacketSent() { return 0; }
unsigned long PerfMon::getErrorSent() { return 0; }
unsigned long PerfMon::getDropSent() { return 0; }
unsigned long PerfMon::getCollisions() { return 0; }

#else

PerfMon::~PerfMon() {}
PerfMon::PerfMon(const char* nic, RTI_UINT32 pid) {}
int PerfMon::isValid() { return 1; }
float PerfMon::getCpu() { return 0.0f; }
unsigned long PerfMon::getMemory() { return 0; }
RTIBool PerfMon::getNetDevStat() { return RTI_TRUE; }
unsigned long PerfMon::getByteReceived() { return 0; }
unsigned long PerfMon::getPacketReceived() { return 0; }
unsigned long PerfMon::getErrorReceived() { return 0; }
unsigned long PerfMon::getDropReceived() { return 0; }
unsigned long PerfMon::getMcastReceived() { return 0; }
unsigned long PerfMon::getByteSent() { return 0; }
unsigned long PerfMon::getPacketSent() { return 0; }
unsigned long PerfMon::getErrorSent() { return 0; }
unsigned long PerfMon::getDropSent() { return 0; }
unsigned long PerfMon::getCollisions() { return 0; }

#endif

